syntax = "proto3";
package mediacontrol;
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "asn1.proto";

message MediaControlMessages {
    repeated MediaControlMessage messages = 1;
}

message MediaControlMessage {
    uint32 messageId = 1;

    oneof variant {
        // Request Messages
        TerminalCapabilitySet terminalCapabilitySet = 2;
        OpenLogicalChannel openLogicalChannel = 3;
        CloseLogicalChannel closeLogicalChannel = 4;
        RequestChannelClose requestChannelClose = 5;
        RequestMode requestMode = 6;
        RoundTripDelayRequest roundTripDelayRequest = 7;
        MaintenanceLoopRequest maintenanceLoopRequest = 8;
        CommunicationModeRequest communicationModeRequest = 9;
        ConferenceRequest conferenceRequest = 10;
        LogicalChannelRateRequest logicalChannelRateRequest = 11;

        // Response Messages
        TerminalCapabilitySetAck terminalCapabilitySetAck = 12;
        TerminalCapabilitySetReject terminalCapabilitySetReject = 13;
        OpenLogicalChannelAck openLogicalChannelAck = 14;
        OpenLogicalChannelReject openLogicalChannelReject = 15;
        CloseLogicalChannelAck closeLogicalChannelAck = 16;
        RequestChannelCloseAck requestChannelCloseAck = 17;
        RequestChannelCloseReject requestChannelCloseReject = 18;
        RequestModeAck requestModeAck = 19;
        RequestModeReject requestModeReject = 20;
        RoundTripDelayResponse roundTripDelayResponse = 21;
        MaintenanceLoopAck maintenanceLoopAck = 22;
        MaintenanceLoopReject maintenanceLoopReject = 23;
        CommunicationModeResponse communicationModeResponse = 24;
        ConferenceResponse conferenceResponse = 25;
        LogicalChannelRateAcknowledge logicalChannelRateAcknowledge = 26;
        LogicalChannelRateReject logicalChannelRateReject = 27;

        // Command Messages
        MaintenanceLoopOffCommand maintenanceLoopOffCommand = 28;
        SendTerminalCapabilitySet sendTerminalCapabilitySet = 29;
        FlowControlCommand flowControlCommand = 30;
        EndSessionCommand endSessionCommand = 31;
        MiscellaneousCommand miscellaneousCommand = 32;
        CommunicationModeCommand communicationModeCommand = 33;
        ConferenceCommand conferenceCommand = 34;

        // Indication Messages
        FunctionNotUnderstood functionNotUnderstood = 35;
        TerminalCapabilitySetRelease terminalCapabilitySetRelease = 36;
        OpenLogicalChannelConfirm openLogicalChannelConfirm = 37;
        RequestChannelCloseRelease requestChannelCloseRelease = 38;
        RequestModeRelease requestModeRelease = 39;
        MiscellaneousIndication miscellaneousIndication = 40;
        JitterIndication jitterIndication = 41;
        UserInputIndication userInput = 42;
        H2250MaximumSkewIndication h2250MaximumSkewIndication = 43;
        MCLocationIndication mcLocationIndication = 44;
        ConferenceIndication conferenceIndication = 45;
        VendorIdentification vendorIdentification = 46;
        FunctionNotSupported functionNotSupported = 47;
        LogicalChannelRateRelease logicalChannelRateRelease = 48;
        FlowControlIndication flowControlIndication = 49;

        uint32 abort = 66; // Value is the messageId of the operation to abort.
    }
}

message TerminalCapabilitySet {
    uint32 sequenceNumber = 1;
    repeated uint32 protocolIdentifier = 2; // TODO: Isn't this an ASN.1 object identifier?
    optional MultiplexCapability multiplexCapability = 3;
    repeated CapabilityTableEntry capabilityTable = 4;
    repeated CapabilityDescriptor capabilityDescriptors = 5;
}

message MediaDistributionCapability {
    bool centralizedControl = 1;
    bool distributedControl = 2;
    bool centralizedAudio = 3;
    bool distributedAudio = 4;
    bool centralizedVideo = 5;
    bool distributedVideo = 6;
    repeated DataApplicationCapability centralizedData = 7;
    repeated DataApplicationCapability distributedData = 8;
}

message MultipointCapability {
    bool multicast = 1;
    bool multiUniCastConference = 2;
    repeated MediaDistributionCapability mediaDistribution = 3;
}

// Equivalent to H2250Capability
message MultiplexCapability {
    uint32 maximumAudioDelayJitter = 1;
    MultipointCapability receiveMultipoint = 2;
    MultipointCapability transmitMultipoint = 3;
    MultipointCapability receiveAndTransmitMultipoint = 4;
    bool centralizedConferenceMC = 5;
    bool decentralizedConferenceMC = 6;
    bool rtcpVideoControl = 7;
    bool h261aVideoPacketization = 8;
    repeated RTPPayloadType rtpPayloadType = 9;
    optional TransportCapability transport = 10;
    repeated RedundancyEncodingCapability redundancyEncoding = 11;
    bool logicalChannelSwitching = 12;
    bool t120DynamicPort = 13;
}

message CapabilityTableEntry {
    uint32 capabilityTableEntryNumber = 1;
    optional Capability capability = 2;
}

enum UserInputCapability {
    USER_INPUT_CAP_DIGITS = 0; // 0-9
    USER_INPUT_CAP_DIALPAD = 1; // 0-9#* (such as on a mobile phone)
    USER_INPUT_CAP_ASCII = 2; // ASCII characters
    USER_INPUT_CAP_BMP = 3; // Basic Multilingual Plane
    USER_INPUT_CAP_UNICODE = 4; // Full Unicode
}

message ConferenceCapability {
    bool chairControlCapability = 1;
    bool videoIndicateMixingCapability = 2;
    bool multipointVisualizationCapability = 3;
}

message AudioTelephonyEventCapability {
    uint32 dynamicRTPPayloadType = 1;
    string audioTelephoneEvent = 2;
}

message NoPTAudioTelephonyEventCapability {
    string audioTelephoneEvent = 1;
}

message AudioToneCapability {
    uint32 dynamicRTPPayloadType = 1;
}

message NoPTAudioToneCapability {
    // Intentionally empty
}

message AlternativeCapabilitySet {
    repeated uint32 capabilityTableEntryNumbers = 1;
}

message MultiplePayloadStreamCapability {
    repeated AlternativeCapabilitySet capabilities = 1;
}

message FECCapability {
    uint32 protectedCapability = 1;
    optional asn1.ObjectIdentifier fecScheme = 2;
    oneof rfc2733Format {
        google.protobuf.Empty omitted = 3;
        uint32 rfc2733rfc2198 = 4;
        uint32 rfc2733sameport = 5;
        uint32 rfc2733diffport = 6;
    }
}

message RedundancyEncodingCapability {
    RedundancyEncodingMethod redundancyEncodingMethod = 1;
    uint32 primaryEncoding = 2;
    repeated uint32 secondaryEncoding = 3;
}

message Capability {
    oneof variant {
        VideoCapability receiveVideoCapability = 1;
        VideoCapability transmitVideoCapability = 2;
        VideoCapability receiveAndTransmitVideoCapability = 3;
        AudioCapability receiveAudioCapability = 4;
        AudioCapability transmitAudioCapability = 5;
        AudioCapability receiveAndTransmitAudioCapability = 6;
        DataApplicationCapability receiveDataApplicationCapability = 7;
        DataApplicationCapability transmitDataApplicationCapability = 8;
        DataApplicationCapability receiveAndTransmitDataApplicationCapability = 9;
        UserInputCapability receiveUserInputCapability = 10;
        UserInputCapability transmitUserInputCapability = 11;
        UserInputCapability receiveAndTransmitUserInputCapability = 12;
        ConferenceCapability conferenceCapability = 13;
        uint32 maxPendingReplacementFor = 14;
        AudioTelephonyEventCapability receiveRTPAudioTelephonyEventCapability = 15;
        AudioToneCapability receiveRTPAudioToneCapability = 16;
        MultiplePayloadStreamCapability multiplePayloadStreamCapability = 17;
        FECCapability fecCapability = 18;
        RedundancyEncodingCapability redundancyEncodingCap = 19;
        AlternativeCapabilitySet oneOfCapabilities = 20;
    }
}

message CapabilityDescriptor {
    uint32 capabilityDescriptorNumber = 1;
    repeated AlternativeCapabilitySet simultaneousCapabilities = 2;
}

message H261VideoCapability {
    uint32 qcifMPI = 1;
    uint32 cifMPI = 2;
    bool temporalSpatialTradeOffCapability = 3;
    uint32 maxBitRate = 4;
    bool stillImageTransmission = 5;
    bool videoBadMBsCap = 6;
}

message H262VideoCapability {
    bool profileAndLevelSPatML = 1;
    bool profileAndLevelMPatLL = 2;
    bool profileAndLevelMPatML = 3;
    bool profileAndLevelMPatH14 = 4;
    bool profileAndLevelMPatHL = 5;
    bool profileAndLevelSNRatLL = 6;
    bool profileAndLevelSNRatML = 7;
    bool profileAndLevelSpatialatH14 = 8;
    bool profileAndLevelHPatML = 9;
    bool profileAndLevelHPatH14 = 10;
    bool profileAndLevelHPatHL = 11;
    optional uint32 videoBitRate = 12;
    optional uint32 vbvBufferSize = 13;
    optional uint32 samplesPerLine = 14;
    optional uint32 linesPerFrame = 15;
    optional uint32 framesPerSecond = 16;
    optional uint32 luminanceSampleRate = 17;
}

message EnhancementOptions {
    uint32 sqcifMPI = 1;
    uint32 qcifMPI = 2;
    uint32 cifMPI = 3;
    uint32 cif4MPI = 4;
    uint32 cif16MPI = 5;
    uint32 maxBitRate = 6;
    bool unrestrictedVector = 7;
    bool arithmeticCoding = 8;
    bool temporalSpatialTradeOffCapability = 9;
    uint32 slowSqcifMPI = 10;
    uint32 slowQcifMPI = 11;
    uint32 slowCifMPI = 12;
    uint32 slowCif4MPI = 13;
    uint32 slowCif16MPI = 14;
    bool errorCompensation = 15;
    optional H263Options h263Options = 16;
    uint32 numberOfBPictures = 17; // Only used for bPictureEnhancement
}

message EnhancementLayerInfo {
    bool baseBitRateConstrained = 1;
    repeated EnhancementOptions snrEnhancement = 2;
    repeated EnhancementOptions spatialEnhancement = 3;
    repeated EnhancementOptions bPictureEnhancement = 4;
}

message TransparencyParameters {
    uint32 presentationOrder = 1;
    int32 offsetX = 2;
    int32 offsetY = 3;
    uint32 scaleX = 4;
    uint32 scaleY = 5;
}

message RefPictureSelection {
    uint32 sqcifAdditionalPictureMemory = 1;
    uint32 qcifAdditionalPictureMemory = 2;
    uint32 cifAdditionalPictureMemory = 3;
    uint32 cif4AdditionalPictureMemory = 4;
    uint32 cif16AdditionalPictureMemory = 5;
    uint32 bigCpfAdditionalPictureMemory = 6;
    bool videoMux = 7;
    oneof videoBackChannelSend {
        google.protobuf.Empty none = 8;
        google.protobuf.Empty ackMessageOnly = 9;
        google.protobuf.Empty nackMessageOnly = 10;
        google.protobuf.Empty ackOrNackMessageOnly = 11;
        google.protobuf.Empty ackAndNackMessage = 12;
    }
    uint32 mpuHorizMBs = 13;
    uint32 mpuVertMBs = 14;
    uint32 mpuTotalNumber = 15;
}

message H263Version3Options {
    bool dataPartitionedSlices = 1;
    bool fixedPointIDCT0 = 2;
    bool interlacedFields = 3;
    bool currentPictureHeaderRepetition = 4;
    bool previousPictureHeaderRepetition = 5;
    bool nextPictureHeaderRepetition = 6;
    bool pictureNumber = 7;
    bool spareReferencePictures = 8;
}

message H263Options {
    bool advancedIntraCodingMode = 1;
    bool deblockingFilterMode = 2;
    bool improvedPBFramesMode = 3;
    bool unlimitedMotionVectors = 4;
    bool fullPictureFreeze = 5;
    bool partialPictureFreezeAndRelease = 6;
    bool resizingPartPicFreezeAndRelease = 7;
    bool fullPictureSnapshot = 8;
    bool partialPictureSnapshot = 9;
    bool videoSegmentTagging = 10;
    bool progressiveRefinement = 11;
    bool dynamicPictureResizingByFour = 12;
    bool dynamicPictureResizingSixteenthPel = 13;
    bool dynamicWarpingHalfPel = 14;
    bool dynamicWarpingSixteenthPel = 15;
    bool independentSegmentDecoding = 16;
    bool slicesInOrderNonRect = 17;
    bool slicesInOrderRect = 18;
    bool slicesNoOrderNonRect = 19;
    bool slicesNoOrderRect = 20;
    bool alternateInterVLCMode = 21;
    bool modifiedQuantizationMode = 22;
    bool reducedResolutionUpdate = 23;
    optional TransparencyParameters transparencyParameters = 24;
    bool separateVideoBackChannel = 25;
    optional RefPictureSelection refPictureSelection = 26;
    uint32 customPictureClockFrequency = 27;
    uint32 customPictureFormat = 28;
    uint32 modeCombos = 29;
    bool videoBadMBsCap = 30;
    H263Version3Options h263Version3Options = 31;
}

message H263VideoCapability {
    uint32 sqcifMPI = 1;
    uint32 qcifMPI = 2;
    uint32 cifMPI = 3;
    uint32 cif4MPI = 4;
    uint32 cif16MPI = 5;
    uint32 maxBitRate = 6;
    bool unrestrictedVector = 7;
    bool arithmeticCoding = 8;
    bool advancedPrediction = 9;
    bool pbFrames = 10;
    bool temporalSpatialTradeOffCapability = 11;
    optional uint32 hrdB = 12;
    optional uint32 bppMaxKb = 13;
    uint32 slowSqcifMPI = 14;
    uint32 slowQcifMPI = 15;
    uint32 slowCifMPI = 16;
    uint32 slowCif4MPI = 17;
    uint32 slowCif16MPI = 18;
    bool errorCompensation = 19;
    optional EnhancementLayerInfo enhancementLayerInfo = 20;
    optional H263Options h263Options = 21;
}

message IS11172VideoCapability {
    bool constrainedBitstream = 1;
    optional uint32 videoBitRate = 2;
    optional uint32 vbvBufferSize = 3;
    optional uint32 samplesPerLine = 4;
    optional uint32 linesPerFrame = 5;
    optional uint32 pictureRate = 6;
    optional uint32 luminanceSampleRate = 7;
    bool videoBadMBsCap = 8;
}

message H264VideoCapability {
    // TODO: Not defined by the ITU.
}

message H265VideoCapability {
    // TODO: Not defined by the ITU.
}

message H266VideoCapability {
    // TODO: Not defined by the ITU.
}

message AV1VideoCapability {
    // TODO: Not defined by the ITU.
}

message VideoCapability {
    oneof variant {
        IS11172VideoCapability is11172VideoCapability = 1;
        H261VideoCapability h261VideoCapability = 2;
        H262VideoCapability h262VideoCapability = 3;
        H263VideoCapability h263VideoCapability = 4;
        H264VideoCapability h264VideoCapability = 5;
        H265VideoCapability h265VideoCapability = 6;
        H266VideoCapability h266VideoCapability = 7;
        AV1VideoCapability av1VideoCapability = 8;
    }
}

message G7231AudioCapability {
    uint32 maxAlSduAudioFrames = 1;
    bool silenceSuppression = 2;
}

message IS11172AudioCapability {
    bool audioLayer1 = 1;
    bool audioLayer2 = 2;
    bool audioLayer3 = 3;
    bool audioSampling32k = 4;
    bool audioSampling44k1 = 5;
    bool audioSampling48k = 6;
    bool singleChannel = 7;
    bool twoChannels = 8;
    uint32 bitRate = 9;
}

message IS13818AudioCapability {
    bool audioLayer1 = 1;
    bool audioLayer2 = 2;
    bool audioLayer3 = 3;
    bool audioSampling16k = 4;
    bool audioSampling22k05 = 5;
    bool audioSampling24k = 6;
    bool audioSampling32k = 7;
    bool audioSampling44k1 = 8;
    bool audioSampling48k = 9;
    bool singleChannel = 10;
    bool twoChannels = 11;
    bool threeChannels2 = 12;
    bool threeChannels3 = 13;
    bool fourChannels2020 = 14;
    bool fourChannels22 = 15;
    bool fourChannels31 = 16;
    bool fiveChannels3020 = 17;
    bool fiveChannels32 = 18;
    bool lowFrequencyEnhancement = 19;
    bool multilingual = 20;
    uint32 bitRate = 21;
}

message G7231AnnexCCapability {
    uint32 maxAlSduAudioFrames = 1;
    bool silenceSuppression = 2;
    uint32 highRateMode0 = 3;
    uint32 highRateMode1 = 4;
    uint32 lowRateMode0 = 5;
    uint32 lowRateMode1 = 6;
    uint32 sidMode0 = 7;
    uint32 sidMode1 = 8;
}

message OpusCapability {
    // TODO:
}

message LyraCapability {
    // TODO:
}

message WavPackCapability {
    // TODO:
}

message FLACCapability {
    // TODO:
}

message ALACCapability {
    // TODO:
}

message AudioCapability {
    oneof variant {
        // the integers indicate the maximum number of audio frames per packet
        uint32 g711Alaw64k = 1;
        uint32 g711Alaw56k = 2;
        uint32 g711Ulaw64k = 3;
        uint32 g711Ulaw56k = 4;
        uint32 g722at64k = 5;
        uint32 g722at56k = 6;
        uint32 g722at48k = 7;
        G7231AudioCapability g7231 = 8;
        uint32 g728 = 9;
        uint32 g729 = 10;
        uint32 g729AnnexA = 11;
        uint32 g729wAnnexB = 12;
        uint32 g729AnnexAwAnnexB = 13;
        IS11172AudioCapability is11172AudioCapability = 14;
        IS13818AudioCapability is13818AudioCapability = 15;
        G7231AnnexCCapability g7231AnnexCCapability = 16;
        NoPTAudioTelephonyEventCapability audioTelephonyEvent = 17;
        NoPTAudioToneCapability audioTone = 18;
        // TODO: GSM Audio was removed from here, because it is unspecified.
        OpusCapability opus = 19;
        LyraCapability lyra = 20;
        FLACCapability flac = 21;
        ALACCapability alac = 22;
        WavPackCapability wavpack = 23;
    }
}

message DataProtocolCapability {
    bool tcp = 1;
    bool udp = 2;
    bool sctp = 3;
    bool tls = 4;
    bool dtls = 5;
}

message DataApplicationCapability {
    uint32 maxBitRate = 1; // Units: 100 bit/s
    oneof application {
        DataProtocolCapability t120 = 2;
        DataProtocolCapability t140 = 3;  
    }
}

message MultiplePayloadStream {
    repeated MultiplePayloadStreamElement elements = 1;
}

message MultiplePayloadStreamElement {
    DataType dataType = 1;
    optional uint32 payloadType = 2;
}

message RFC2733FECData {
    uint32 protectedPayloadType = 1;
    optional asn1.ObjectIdentifier fecScheme = 2;
    oneof pktMode {
        google.protobuf.Empty rfc2198coding = 3;
        google.protobuf.Empty rfc2733sameport = 4;
        uint32 rfc2733diffport = 5;
    }
}

message FECData {
    oneof variant {
        RFC2733FECData rfc2733 = 1;
    }
}

message DataType {
    oneof variant {
        google.protobuf.Empty null = 1;
        VideoCapability video = 2;
        AudioCapability audio = 3;
        DataApplicationCapability data = 4;
        MultiplePayloadStream multiplePayloadStream = 5;
        FECData fec = 6; // Forward Error Correction
    }
}

message IPAddress {
    oneof version {
        bytes v4 = 1;
        bytes v6 = 2;
    }
}

message TransportAddress {
    bool multicast = 1;
    oneof variant {
        IPAddress ipAddress = 2;
        string hostname = 3;
    }
    uint32 port = 4;
}

message TerminalLabel {
    uint32 mcuNumber = 1;
    uint32 terminalNumber = 2;
}

message RTPPayloadType {
    optional uint32 payloadType = 1;
    oneof payloadDescriptor {
        uint32 ietfRfc = 2;
        asn1.ObjectIdentifier oid = 3;
    }
}

// Defined in ITU-T Y.1541.
enum QOSClass {
    QOS_CLASS_0 = 0;
    QOS_CLASS_1 = 1;
    QOS_CLASS_2 = 2;
    QOS_CLASS_3 = 3;
    QOS_CLASS_4 = 4;
    QOS_CLASS_5 = 5;
}

// Defined in clause 6.1 of ITU-T H.361.
message ServicePriority {
    bool signalled = 1;
    optional uint32 value = 2;
    optional uint32 class = 3;
    optional uint32 subclass = 4;
    bool qosTypeRequired = 5;
    QOSClass qosClass = 6;
    optional uint32 dscpValue = 7; // Differentiated Service Code Point. Used in IP Networking.
}

message QOSCapability {
    // localQoS is unexplained.
    // GenericTransportParameters genericTransportParameters = 1;
    uint32 averageRate = 1;
    uint32 burst = 2;
    uint32 peakRate = 3;
    uint32 maxPktSize = 4;
    optional ServicePriority servicePriority = 5;
}

message MediaChannelCapabilities {
    bool udp = 1;
    bool tcp = 2;
}

message TransportCapability {
    repeated QOSCapability qOSCapabilities = 1;
    MediaChannelCapabilities mediaChannelCapabilities = 2;
}

message RedundancyEncodingElement {
    DataType dataType = 1;
    optional uint32 payloadType = 2;
}

message RTPRedundancyEncoding {
    optional RedundancyEncodingElement primary = 1;
    repeated RedundancyEncodingElement secondary = 2;
}

message RTPH263VideoRedundancyFrameMapping {
    uint32 threadNumber = 1;
    repeated uint32 frameSequence = 2;
}

message CustomFrameToThreadMapping {
    repeated RTPH263VideoRedundancyFrameMapping mappings = 1;
}

message RTPH263VideoRedundancyEncoding {
    uint32 numberOfThreads = 1;
    uint32 framesBetweenSyncPoints = 2;
    repeated uint32 containedThreads = 3;
    oneof frameToThreadMapping {
        google.protobuf.Empty roundrobin = 4;
        CustomFrameToThreadMapping custom = 5;
    }
}

message RedundancyEncoding {
    optional DataType secondaryEncoding = 1;
    optional RTPRedundancyEncoding rtpRedundancy = 2;
    RedundancyEncodingMethod redundancyEncodingMethod = 3;
}

message H2250LogicalChannelParameters {
    uint32 sessionID = 1;
    uint32 associatedSessionID = 2;
    optional TransportAddress mediaChannel = 3;
    optional bool mediaGuaranteedDelivery = 4;
    optional TransportAddress mediaControlChannel = 5;
    optional bool mediaControlGuaranteedDelivery = 6;
    optional bool silenceSuppression = 7;
    optional TerminalLabel destination = 8;
    uint32 dynamicRTPPayloadType = 9;
    oneof mediaPacketization {
        google.protobuf.Empty omitted = 10;
        google.protobuf.Empty h261aVideoPacketization = 11;
        RTPPayloadType rtpPayloadType = 12;
    }
    optional TransportCapability transportCapability = 13;
    optional RedundancyEncoding redundancyEncoding = 14;
    optional TerminalLabel source = 15;
}

message ForwardLogicalChannelParams {
    uint32 portNumber = 1;
    DataType dataType = 2;
    // The other H.245 alternatives will not be supported.
    H2250LogicalChannelParameters multiplexParameters = 3;
    uint32 forwardLogicalChannelDependency = 4;
    uint32 replacementFor = 5;
}

message ReverseLogicalChannelParameters {
    uint32 logicalChannelNumber = 1;
    DataType dataType = 2;
    H2250LogicalChannelParameters multiplexParameters = 3;
    uint32 reverseLogicalChannelDependency = 4;
    uint32 replacementFor = 5;
}

message NetworkAccessParameters {
    bool multicast = 1;
    TransportAddress networkAddress = 2;
    bool associateConference = 3;
    bytes externalReference = 4;
    oneof t120SetupProcedure {
        google.protobuf.Empty omitted = 5;
        google.protobuf.Empty originateCall = 6;
        google.protobuf.Empty waitForCall = 7;
        google.protobuf.Empty issueQuery = 8;
    }
}

message EscrowData {
    asn1.ObjectIdentifier escrowID = 1;
    asn1.BitString escrowValue = 2;
}

message EncryptionSync {
    uint32 synchFlag = 1;
    bytes h235Key = 2;
    repeated EscrowData escrowentry = 3;
}

message OpenLogicalChannel {
    uint32 forwardLogicalChannelNumber = 1;
    ForwardLogicalChannelParams forward = 2;
    optional ReverseLogicalChannelParameters reverse = 3;
    optional NetworkAccessParameters separateStack = 4;
    optional EncryptionSync encryptionSync = 5;
}

enum CloseLogicalChannelReason {
    CLC_REASON_UNKNOWN = 0;
    CLC_REASON_REOPEN = 1;
    CLC_REASON_RESERVATION_FAILURE = 2;
    CLC_REASON_NETWORK_ERROR = 3;
}

message CloseLogicalChannel {
    uint32 forwardLogicalChannelNumber = 1;
    bool sourceLCSE = 2;
    CloseLogicalChannelReason reason = 3;
    uint32 networkErrorCode = 4;
}

message RequestChannelClose {
    uint32 forwardLogicalChannelNumber = 1;
    optional QOSCapability qos = 2;
    CloseLogicalChannelReason reason = 3;
    uint32 networkErrorCode = 4;
}

message H261VideoMode {
    bool qcif = 1;
    uint32 bitRate = 2;
    bool stillImageTransmission = 3;
}

enum H262VideoModeProfile {
    H262_PROFILE_SPATML = 0;
    H262_PROFILE_MPATLL = 1;
    H262_PROFILE_MPATML = 2;
    H262_PROFILE_MPATH14 = 3;
    H262_PROFILE_MPATHL = 4;
    H262_PROFILE_SNRATLL = 5;
    H262_PROFILE_SNRATML = 6;
    H262_PROFILE_SPATIALATH14 = 7;
    H262_PROFILE_HPATML = 8;
    H262_PROFILE_HPATH14 = 9;
    H262_PROFILE_HPATHL = 10;
}

message H262VideoMode {
    H262VideoModeProfile profileAndLevel = 1;
    optional uint32 videoBitRate = 2;
    optional uint32 vbvBufferSize = 3;
    optional uint32 samplesPerLine = 4;
    optional uint32 linesPerFrame = 5;
    optional uint32 framesPerSecond = 6;
    optional uint32 luminanceSampleRate = 7;
}

enum H263VideoModeResolution {
    H263_RESOLUTION_SQCIF = 0;
    H263_RESOLUTION_QCIF = 1;
    H263_RESOLUTION_CIF = 2;
    H263_RESOLUTION_CIF4 = 3;
    H263_RESOLUTION_CIF16 = 4;
    H263_RESOLUTION_CUSTOM = 5;
}

message H263VideoMode {
    H263VideoModeResolution resolution = 1;
    uint32 bitRate = 2; // Units: 100 bit/s
    bool unrestrictedVector = 3;
    bool arithmeticCoding = 4;
    bool advancedPrediction = 5;
    bool pbFrames = 6;
    bool errorCompensation = 7;
    optional EnhancementLayerInfo enhancementLayerInfo = 8;
    optional H263Options h263Options = 9;
}

message H264VideoMode {
    // TODO:
}

message H265VideoMode {
    // TODO:
}

message H266VideoMode {
    // TODO:
}

message IS11172VideoMode {
    bool constrainedBitstream = 1;
    optional uint32 videoBitRate = 2;
    optional uint32 vbvBufferSize = 3;
    optional uint32 samplesPerLine = 4;
    optional uint32 linesPerFrame = 5;
    optional uint32 pictureRate = 6;
    optional uint32 luminanceSampleRate = 7;
}

message AV1VideoMode {
    // TODO:
}

message VideoMode {
    oneof variant {
        H261VideoMode h261 = 1;
        H262VideoMode h262 = 2;
        H263VideoMode h263 = 3;
        H264VideoMode h264 = 4;
        H265VideoMode h265 = 5;
        H266VideoMode h266 = 6;
        IS11172VideoMode is11172 = 7;
        AV1VideoMode av1 = 8;
    }
}

message G7231AudioMode {
    bool silenceSuppression = 1;
    bool highRate = 2;
}

message IS11172AudioMode {
    bool audioLayer1 = 1;
    bool audioLayer2 = 2;
    bool audioLayer3 = 3;
    bool audioSampling32k = 4;
    bool audioSampling44k1 = 5;
    bool audioSampling48k = 6;
    bool singleChannel = 7;
    bool twoChannels = 8;
    uint32 kbitRate = 9;
}

message IS13818AudioMode {
    bool audioLayer1 = 1;
    bool audioLayer2 = 2;
    bool audioLayer3 = 3;
    bool audioSampling16k = 4;
    bool audioSampling22k05 = 5;
    bool audioSampling24k = 6;
    bool audioSampling32k = 7;
    bool audioSampling44k1 = 8;
    bool audioSampling48k = 9;
    bool singleChannel = 10;
    bool twoChannels = 11;
    bool threeChannels21 = 12;
    bool threeChannels30 = 13;
    bool fourChannels2020 = 14;
    bool fourChannels22 = 15;
    bool fourChannels31 = 16;
    bool fiveChannels3020 = 17;
    bool fiveChannels32 = 18;
    bool lowFrequencyEnhancement = 19;
    bool multilingual = 20;
    uint32 kbitRate = 21;
}

message G7231AnnexCMode {
    uint32 maxAlsduAudioFrames = 1;
    bool silenceSuppression = 2;
    uint32 highRateMode0 = 3; // Units in octets
    uint32 highRateMode1 = 4; // Units in octets
    uint32 lowRateMode0 = 5; // Units in octets
    uint32 lowRateMode1 = 6; // Units in octets
    uint32 sidMode0 = 7; // Units in octets
    uint32 sidMode1 = 8; // Units in octets
}

message G729Extensions {
    uint32 audioUnit = 1;
    bool annexA = 2;
    bool annexB = 3;
    bool annexD = 4;
    bool annexE = 5;
    bool annexF = 6;
    bool annexG = 7;
    bool annexH = 8;
}

message WavPackAudioMode {
    // TODO:
}

message OpusAudioMode {
    // TODO:
}

message LyraAudioMode {
    // TODO: 
}

message FLACAudioMode {
    // TODO: 
}

message ALACAudioMode {
    // TODO: 
}

message AudioMode {
    oneof variant {
        google.protobuf.Empty g711Alaw64k = 1;
        google.protobuf.Empty g711Alaw56k = 2;
        google.protobuf.Empty g711Ulaw64k = 3;
        google.protobuf.Empty g711Ulaw56k = 4;
        google.protobuf.Empty g722at64k = 5;
        google.protobuf.Empty g722at56k = 6;
        google.protobuf.Empty g722at48k = 7;
        google.protobuf.Empty g728 = 8;
        G729Extensions g729 = 9;
        G7231AudioMode g7231 = 10;
        IS11172AudioMode is11172 = 11;
        IS13818AudioMode is13818 = 12;
        uint32 g729wAnnexB = 13;
        uint32 g729AnnexAwAnnexB = 14;
        G7231AnnexCMode g7231AnnexCMode = 15;
        WavPackAudioMode wavpack = 16;
        OpusAudioMode opus = 17;
        LyraAudioMode lyra = 18;
        FLACAudioMode flac = 19;
        ALACAudioMode alac = 20;
    }
}

message DataMode {
    uint32 bitRate = 1; // Units: 100 bits/s
    oneof variant {
        DataProtocolCapability t120 = 2;
        DataProtocolCapability t140 = 3;
    }
}

message MultiplePayloadStreamMode {
    repeated ModeElementType elements = 1;
}

message FECMode {
    ModeElementType protectedElement = 1;
    optional asn1.ObjectIdentifier fecScheme = 2;
    oneof rfc2733Format {
        google.protobuf.Empty omitted = 3;
        uint32 rfc2733rfc2198 = 4;
        uint32 rfc2733sameport = 5;
        uint32 rfc2733diffport = 6;
    }
}

message ModeElementType {
    oneof variant {
        VideoMode video = 1;
        AudioMode audio = 2;
        DataMode data = 3;
        MultiplePayloadStreamMode multi = 4;
        FECMode fec = 5;
    }
}

message RedundancyEncodingMethod {
    oneof variant {
        google.protobuf.Empty rtpAudioRedundancyEncoding = 1;
        RTPH263VideoRedundancyEncoding rtpH263VideoRedundancyEncoding = 2;
    }
}

message RedundancyEncodingMode {
    RedundancyEncodingMethod method = 1;
    optional AudioMode secondaryEncoding = 2;
}

message H2250ModeParameters {
    optional RedundancyEncodingMode redundancyEncodingMode = 1;
}

message GenericCapability {
    asn1.ObjectIdentifier identifier = 1;
    uint32 maxBitRate = 2; // Units: bit/s
}

message MultiplexedStreamModeParameters {
    uint32 logicalChannelNumber = 1;
}

message ModeElement {
    ModeElementType type = 1;
    H2250ModeParameters h2250ModeParameters = 2;
    optional GenericCapability genericModeParameters = 3;
    optional MultiplexedStreamModeParameters multiplexedStreamModeParameters = 4;
    uint32 logicalChannelNumber = 5;
}

message ModeDescription {
    repeated ModeElement elements = 1;
}

message RequestMode {
    uint32 sequenceNumber = 1;
    repeated ModeDescription requestedModes = 2;
}

message RoundTripDelayRequest {
    uint32 sequenceNumber = 1;
}

message MaintenanceLoopRequest {
    oneof type {
        google.protobuf.Empty systemLoop = 1;
        uint32 mediaLoop = 2;
        uint32 logicalChannelLoop = 3;
    }
}

message CommunicationModeRequest {
    // Intentionally empty
}

message LogicalChannelRateRequest {
    uint32 sequenceNumber = 1;
    uint32 logicalChannelNumber = 2;
    uint32 maximumBitRate = 3;
}

message TerminalCapabilitySetAck {
    uint32 sequenceNumber = 1;
}

enum TermCapSetRejectCause {
    TERM_CAP_SET_REJECT_CAUSE_UNSPECIFIED = 0;
    TERM_CAP_SET_REJECT_CAUSE_UNDEFINED_ENTRY = 1;
    TERM_CAP_SET_REJECT_CAUSE_DESCRIPTOR_CAP_EXCEEDED = 2;
    TERM_CAP_SET_REJECT_CAUSE_TABLE_ENTRY_CAP_EXCEEDED = 3;
}

message TerminalCapabilitySetReject {
    uint32 sequenceNumber = 1;
    TermCapSetRejectCause cause = 2;
}

message H2250LogicalChannelAckParameters {
    uint32 sessionID = 1;
    optional TransportAddress mediaChannel = 2;
    optional TransportAddress mediaControlChannel = 3;
    optional uint32 dynamicRTPPayloadType = 4;
    bool flowControlToZero = 5;

    // TODO: I kind of think you should just get rid of this. It is confusing and not used.
    optional uint32 portNumber = 6;
}

message OpenLogicalChannelAck {
    uint32 forwardLogicalChannelNumber = 1;
    optional ReverseLogicalChannelParameters reverse = 2;
    optional NetworkAccessParameters separateStack = 3;
    optional H2250LogicalChannelAckParameters h2250LogicalChannelAckParameters = 4;
    optional EncryptionSync encryptionSync = 5;
    optional MultiplePayloadStream multiplePayloadStream = 6;
}

enum OpenLogChannelRejectCause {
    OPEN_LC_REJ_CAUSE_UNSPECIFIED = 0;
    OPEN_LC_REJ_CAUSE_UNSUITABLE_REV_PARAMS = 1;
    OPEN_LC_REJ_CAUSE_DATA_TYPE_NOT_SUPPORTED = 2;
    OPEN_LC_REJ_CAUSE_DATA_TYPE_NOT_AVAILABLE = 3;
    OPEN_LC_REJ_CAUSE_UNKNOWN_DATA_TYPE = 4;
    OPEN_LC_REJ_CAUSE_DATA_TYPE_AL_COMBO_NOT_SUPPORTED = 5;
    OPEN_LC_REJ_CAUSE_MULTICAST_CHANNEL_NOT_ALLOWED = 6;
    OPEN_LC_REJ_CAUSE_INSUFFICIENT_BANDWIDTH = 7;
    OPEN_LC_REJ_CAUSE_SEPARATE_STACK_ESTAB_FAILED = 8;
    OPEN_LC_REJ_CAUSE_INVALID_SESSION_ID = 9;
    OPEN_LC_REJ_CAUSE_MASTER_SLAVE_CONFLICT = 10;
    OPEN_LC_REJ_CAUSE_WAIT_FOR_COMM_MODE = 11;
    OPEN_LC_REJ_CAUSE_INVALID_DEPENDENT_CHANNEL = 12;
    OPEN_LC_REJ_CAUSE_REPLACEMENT_FOR_REJECTED = 13;
    OPEN_LC_REJ_CAUSE_SECURITY = 14;
    OPEN_LC_REJ_CAUSE_QOS_CONTROL_NOT_SUPPORTED = 15;
}

message OpenLogicalChannelReject {
    uint32 forwardLogicalChannelNumber = 1;
    OpenLogChannelRejectCause cause = 2;
}

message CloseLogicalChannelAck {
    uint32 forwardLogicalChannelNumber = 1;
}

message RequestChannelCloseAck {
    uint32 forwardLogicalChannelNumber = 1;
}

message RequestChannelCloseReject {
    uint32 forwardLogicalChannelNumber = 1;
}

message RequestModeAck {
    uint32 sequenceNumber = 1;
    bool willTransmitMostPreferredMode = 2;
}

enum RequestModeRejectCause {
    REQ_MODE_REJ_CAUSE_UNAVAILABLE = 0;
    REQ_MODE_REJ_CAUSE_MULTIPOINT_CONSTRAINT = 1;
    REQ_MODE_REJ_CAUSE_DENIED = 2;
}

message RequestModeReject {
    uint32 sequenceNumber = 1;
    RequestModeRejectCause cause = 2;
}

message RoundTripDelayResponse {
    uint32 sequenceNumber = 1;
}

message MaintenanceLoopAck {
    oneof type {
        google.protobuf.Empty systemLoop = 1;
        uint32 mediaLoop = 2;
        uint32 logicalChannelLoop = 3;
    }
}

message MaintenanceLoopReject {
    oneof type {
        google.protobuf.Empty systemLoop = 1;
        uint32 mediaLoop = 2;
        uint32 logicalChannelLoop = 3;
    }
    // cause is always canNotPerformLoop
}

message CommunicationModeResponse {
    repeated CommunicationModeTableEntry table = 1;
}

message LogicalChannelRateAcknowledge {
    uint32 sequenceNumber = 1;
    uint32 logicalChannelNumber = 2;
    uint32 maximumBitRate = 3;
}

message LogicalChannelRateReject {
    uint32 sequenceNumber = 1;
    uint32 logicalChannelNumber = 2;
    uint32 maximumBitRate = 3;
    bool insufficientResources = 4;
}

message MaintenanceLoopOffCommand {
    // Intentionally empty
}

message SendSpecificTerminalCapabilities {
    bool multiplexCapability = 1;
    repeated uint32 capabilityTableEntryNumbers = 2;
    repeated uint32 capabilityDescriptorNumbers = 3;
}

message SendTerminalCapabilitySet {
    optional SendSpecificTerminalCapabilities specificRequest = 1;
}

message FlowControlCommand {
    oneof scope {
        uint32 logicalChannelNumber = 1;
        uint32 resourceID = 2;
        google.protobuf.Empty wholeMultiplex = 3;
    }
    optional uint32 maximumBitRate = 4; // 0 could be used to "pause"
}

message EndSessionCommand {
    // Intentionally empty
}

message CommunicationModeTableEntry {
    uint32 sessionID = 1;
    uint32 associatedSessionID = 2;
    optional TerminalLabel terminalLabel = 3;
    string sessionDescription = 4;
    oneof dataType {
        VideoCapability video = 5;
        AudioCapability audio = 6;
        DataApplicationCapability app = 7;
    }
    optional TransportAddress mediaChannel = 8;
    optional bool mediaGuaranteedDelivery = 9;
    optional TransportAddress mediaControlChannel = 10;
    optional bool mediaControlGuaranteedDelivery = 11;
    optional RedundancyEncoding redundancyEncoding = 12;
    uint32 sessionDependency = 13;
    optional TerminalLabel destination = 14;
}

message CommunicationModeCommand {
    repeated CommunicationModeTableEntry table = 1;
}

message FunctionNotUnderstood {
    uint32 messageId = 1;
}

message TerminalCapabilitySetRelease {
    // Intentionally empty
}

message OpenLogicalChannelConfirm {
    uint32 forwardLogicalChannelNumber = 1;
}

message RequestChannelCloseRelease {
    uint32 forwardLogicalChannelNumber = 1;
}

message RequestModeRelease {
    // Intentionally empty
}

message JitterIndication {
    oneof scope {
        uint32 logicalChannelNumber = 1;
        uint32 resourceID = 2;
        google.protobuf.Empty wholeMultiplex = 3;
    }
    uint32 estimatedReceivedJitterMantissa = 4;
    uint32 estimatedReceivedJitterExponent = 5;
    optional uint32 skippedFrameCount = 6;
    optional uint32 additionalDecoderBuffer = 7;
}

message UserInputIndication {
    string userInput = 1;
    uint32 duration = 2; // Units: Milliseconds
    optional google.protobuf.Timestamp timestamp = 3;
    optional google.protobuf.Timestamp expirationTime = 4;
    uint32 logicalChannelNumber = 5;
}

message H2250MaximumSkewIndication {
    uint32 logicalChannelNumber1 = 1;
    uint32 logicalChannelNumber2 = 2;
    uint32 maximumSkew = 3;
}

message MCLocationIndication {
    TransportAddress signalAddress = 1;
}

message VendorIdentification {
    asn1.ObjectIdentifier oid = 1;
    uint32 productNumber = 2;
    uint32 versionNumber = 3;

    // More sensible fields.
    string vendorName = 4;
    string productVersion = 5;
}

enum FunctionNotSupportedCause {
    FN_NOT_SUPPORTED_CAUSE_SYNTAX = 0;
    FN_NOT_SUPPORTED_CAUSE_SEMANTIC = 1;
    FN_NOT_SUPPORTED_CAUSE_UNKNOWN = 2;
}

message FunctionNotSupported {
    FunctionNotSupportedCause cause = 1;
    bytes returnedFunction = 2;
}

message LogicalChannelRateRelease {
    // Intentionally Empty
}

message FlowControlIndication {
    oneof scope {
        uint32 logicalChannelNumber = 1;
        uint32 resourceID = 2;
        google.protobuf.Empty wholeMultiplex = 3;
    }
    optional uint32 maximumBitRate = 4;
}

message Criteria {
    asn1.ObjectIdentifier field = 1;
    bytes values = 2;
}

message CertSelectionCriteria {
    repeated Criteria criteria = 1;
}

message RequestTerminalCertArg {
    optional TerminalLabel terminalLabel = 1;
    optional CertSelectionCriteria certSelectionCriteria = 2;
    uint32 sRandom = 3;
}

message RemoteMCRequest {
    oneof variant {
        google.protobuf.Empty masterActivate = 1;
        google.protobuf.Empty slaveActivate = 2;
        google.protobuf.Empty deActivate = 3;
    }
}

message ConferenceRequest {
    oneof variant {
        google.protobuf.Empty terminalListRequest = 1;
        google.protobuf.Empty makeMeChair = 2;
        google.protobuf.Empty cancelMakeMeChair = 3;
        TerminalLabel dropTerminal = 4;
        TerminalLabel requestTerminalID = 5;
        // TODO: Rename without specification
        google.protobuf.Empty enterH243Password = 6;
        google.protobuf.Empty enterH243TerminalID = 7;
        google.protobuf.Empty enterH243ConferenceID = 8;
        google.protobuf.Empty enterExtensionAddress = 9;
        google.protobuf.Empty requestChairTokenOwner = 10;
        RequestTerminalCertArg requestTerminalCertificate = 11;
        uint32 broadcastMyLogicalChannel = 12;
        TerminalLabel makeTerminalBroadcaster = 13;
        TerminalLabel sendThisSource = 14;
        google.protobuf.Empty requestAllTerminalIDs = 15;
        RemoteMCRequest remoteMCRequest = 16;
    }
}

message TerminalInformation {
    TerminalLabel terminalLabel = 1;
    string terminalID = 2;
}

message ConferenceIDResponse {
    TerminalLabel terminalLabel = 1;
    bytes conferenceID = 2;
}

message PasswordResponse {
    TerminalLabel terminalLabel = 1;
    string password = 2;
}

message TerminalListResponse {
    repeated TerminalLabel terminals = 1;
}

message TerminalCertificateResponse {
    TerminalLabel terminalLabel = 1;
    bytes certificate = 2;
}

message RequestAllTerminalIDsResponse {
    repeated TerminalInformation terminals = 1;
}

message RemoteMCResponse {
    bool accepted = 1;
    bool functionNotSupported = 2;
}

message ConferenceResponse {
    oneof variant {
        TerminalInformation mCTerminalIDResponse = 1;
        TerminalInformation terminalIDResponse = 2;
        ConferenceIDResponse conferenceIDResponse = 3;
        PasswordResponse passwordResponse = 4;
        TerminalListResponse terminalListResponse = 5;
        google.protobuf.Empty videoCommandReject = 6;
        google.protobuf.Empty terminalDropReject = 7;
        bool makeMeChairResponse = 8; // TRUE = granted.
        string extensionAddressResponse = 9;
        TerminalInformation chairTokenOwnerResponse = 10;
        TerminalCertificateResponse terminalCertificateResponse = 11;
        bool broadcastMyLogicalChannelResponse = 12; // TRUE = granted
        bool makeTerminalBroadcasterResponse = 13; // TRUE = granted
        bool sendThisSourceResponse = 14; // TRUE = granted
        RequestAllTerminalIDsResponse requestAllTerminalIDsResponse = 15;
        RemoteMCResponse remoteMCResponse = 16;
    }
}

message SubstituteConferenceIDCommand {
    bytes conferenceIdentifier = 1; // UUID of Conference
}

message ConferenceCommand {
    uint32 broadcastMyLogicalChannel = 1;
    uint32 cancelBroadcastMyLogicalChannel = 2;
    TerminalLabel makeTerminalBroadcaster = 3;
    google.protobuf.Empty cancelMakeTerminalBroadcaster = 4;
    TerminalLabel sendThisSource = 5;
    google.protobuf.Empty cancelSendThisSource = 6;
    google.protobuf.Empty dropConference = 7;
    SubstituteConferenceIDCommand substituteConferenceIDCommand = 8;
}

message TerminalYouAreSeeingInSubPictureNumber {
    uint32 terminalNumber = 1;
    uint32 subPictureNumber = 2;
    uint32 mcuNumber = 3;
}

message ConferenceIndication {
    uint32 sbeNumber = 1;
    TerminalLabel terminalNumberAssign = 2;
    TerminalLabel terminalJoinedConference = 3;
    TerminalLabel terminalLeftConference = 4;
    google.protobuf.Empty seenByAtLeastOneOther = 5;
    google.protobuf.Empty cancelSeenByAtLeastOneOther = 6;
    google.protobuf.Empty seenByAll = 7;
    google.protobuf.Empty cancelSeenByAll = 8;
    TerminalLabel terminalYouAreSeeing = 9;
    google.protobuf.Empty requestForFloor = 10;
    google.protobuf.Empty withdrawChairToken = 11;
    TerminalLabel floorRequested = 12;
    TerminalYouAreSeeingInSubPictureNumber terminalYouAreSeeingInSubPictureNumber = 13;
    uint32 videoIndicateCompose = 14;
    google.protobuf.Empty masterMCU = 15;
    google.protobuf.Empty cancelMasterMCU = 16;
}

message VideoFastUpdateGOB {
    uint32 firstGOB = 1;
    uint32 numberOfGOBs = 2;
}

message VideoFastUpdateMB {
    uint32 firstGOB = 1;
    uint32 numberOfGOBs = 2;
    uint32 numberOfMBs = 3;
}

message KeyProtectionMethod {
    bool secureChannel = 1;
    bool sharedSecret = 2;
    bool certProtectedKey = 3;
}

message EncryptionUpdateRequest {
    KeyProtectionMethod keyProtectionMethod = 1;
    uint32 synchFlag = 2;
}

enum ProgressiveEnhancementRepeatCount {
    PROG_ENH_ONE = 0;
    PROG_ENH_CONTINUOUS = 1;
    PROG_ENH_ONE_INDEPENDENT = 2;
    PROG_ENH_CONTINUOUS_INDEPENDENT = 3;
}

message ProgressiveRefinementStart {
    ProgressiveEnhancementRepeatCount repeatCount = 1;
}

message VideoBadMBs {
    uint32 firstMB = 1;
    uint32 numberOfMBs = 2;
    uint32 temporalReference = 3;
}

message PictureReference {
    uint32 pictureNumber = 1;
    uint32 longTermPictureIndex = 2;
}

message LostPicture {
    repeated PictureReference references = 1;
}

message LostPartialPicture {
    PictureReference pictureReference = 1;
    uint32 firstMB = 2;
    uint32 numberOfMBs = 3; 
}

message RecoveryReferencePicture {
    repeated PictureReference references = 1;
}

message EncryptionUpdateCommand {
    EncryptionSync encryptionSync = 1;
    optional MultiplePayloadStream multiplePayloadStream = 2;
}

message MiscellaneousCommand {
    uint32 logicalChannelNumber = 1;
    oneof type {
        google.protobuf.Empty equaliseDelay = 2;
        google.protobuf.Empty zeroDelay = 3;
        google.protobuf.Empty multipointModeCommand = 4;
        google.protobuf.Empty cancelMultipointModeCommand = 5;
        google.protobuf.Empty videoFreezePicture = 6;
        google.protobuf.Empty videoFastUpdatePicture = 7;
        VideoFastUpdateGOB videoFastUpdateGOB = 8;
        uint32 videoTemporalSpatialTradeOff = 9;
        google.protobuf.Empty videoSendSyncEveryGOB = 10;
        google.protobuf.Empty videoSendSyncEveryGOBCancel = 11;
        VideoFastUpdateMB videoFastUpdateMB = 12;
        uint32 maxH223MUXPDUsize = 13;
        EncryptionSync encryptionUpdate = 14;
        EncryptionUpdateRequest encryptionUpdateRequest = 15;
        google.protobuf.Empty switchReceiveMediaOff = 16;
        google.protobuf.Empty switchReceiveMediaOn = 17;
        ProgressiveRefinementStart progressiveRefinementStart = 18;
        google.protobuf.Empty progressiveRefinementAbortOne = 19;
        google.protobuf.Empty progressiveRefinementAbortContinuous = 20;
        VideoBadMBs videoBadMBs = 21;
        LostPicture lostPicture = 22;
        LostPartialPicture lostPartialPicture = 23;
        RecoveryReferencePicture recoveryReferencePicture = 24;
        EncryptionUpdateCommand encryptionUpdateCommand = 25;
        uint32 encryptionUpdateAck = 26; // value is the synchFlag
    }
    bool slaveToMaster = 27;
}

message VideoNotDecodedMB {
    uint32 firstMB = 1;
    uint32 numberOfMBs = 2;
    uint32 temporalReference = 3;
}

message MiscellaneousIndication {
    uint32 logicalChannelNumber = 1;
    oneof type {
        google.protobuf.Empty logicalChannelActive = 2;
        google.protobuf.Empty logicalChannelInactive = 3;
        google.protobuf.Empty multipointConference = 4;
        google.protobuf.Empty cancelMultipointConference = 5;
        google.protobuf.Empty multipointZeroComm = 6;
        google.protobuf.Empty cancelMultipointZeroComm = 7;
        google.protobuf.Empty multipointSecondaryStatus = 8;
        google.protobuf.Empty cancelMultipointSecondaryStatus = 9;
        google.protobuf.Empty videoIndicateReadyToActivate = 10;
        uint32 videoTemporalSpatialTradeOff = 11;
        VideoNotDecodedMB videoNotDecodedMBs = 12;
        TransportCapability transportCapability = 13;
    }
}

// RPC-specific message types

message DiscloseTerminalCapabilitiesOutcome {
    oneof outcome {
        TerminalCapabilitySetAck ack = 1;
        TerminalCapabilitySetReject reject = 2;
    }
}

message OpenLogicalChannelOutcome {
    oneof outcome {
        OpenLogicalChannelAck ack = 1;
        OpenLogicalChannelReject reject = 2;
    }
}

message RequestChannelCloseOutcome {
    oneof outcome {
        RequestChannelCloseAck ack = 1;
        RequestChannelCloseReject reject = 2;
    }
}

message RequestModeOutcome {
    oneof outcome {
        RequestModeAck ack = 1;
        RequestModeReject reject = 2;
    }
}

message LoopOutcome {
    oneof outcome {
        MaintenanceLoopAck ack = 1;
        MaintenanceLoopReject reject = 2;
    }
}

message RequestRateOutcome {
    oneof outcome {
        LogicalChannelRateAcknowledge ack = 1;
        LogicalChannelRateReject reject = 2;
    }
}

message Uint32Wrapper {
    uint32 value = 1;
}

message BoolWrapper {
    bool value = 1;
}

/* This is NOT part of the protocol, because it would require both media peers
to act as servers in both directions. It is defined to be informative, or
perhaps for debugging or experimentation purposes. */
service MediaControl {
    rpc DiscloseTerminalCapabilities (TerminalCapabilitySet) returns (DiscloseTerminalCapabilitiesOutcome);
    rpc DoOpenLogicalChannel (OpenLogicalChannel) returns (OpenLogicalChannelOutcome);
    rpc DoCloseLogicalChannel (CloseLogicalChannel) returns (CloseLogicalChannelAck); // There is no reject for this.
    rpc DoRequestChannelClose (RequestChannelClose) returns (RequestChannelCloseOutcome);
    rpc DoRequestMode (RequestMode) returns (RequestModeOutcome);
    rpc DoDetermineRoundTripDelay (RoundTripDelayRequest) returns (RoundTripDelayResponse);
    rpc DoLoop (MaintenanceLoopRequest) returns (LoopOutcome);
    rpc DoUnloop (MaintenanceLoopOffCommand) returns (google.protobuf.Empty);
    rpc DoGetCommunicationMode (CommunicationModeRequest) returns (CommunicationModeResponse);
    rpc DoUpdateCommunicationMode (CommunicationModeCommand) returns (google.protobuf.Empty);
    rpc DoRequestTerminalCapabilities (SendTerminalCapabilitySet) returns (TerminalCapabilitySet);
    rpc DoRequestRate (LogicalChannelRateRequest) returns (RequestRateOutcome);
    rpc DoControlFlow (FlowControlCommand) returns (FlowControlIndication);
    rpc DoEndSession (EndSessionCommand) returns (google.protobuf.Empty);
    // TODO: Do I need to implement these?
    // rpc Shrug (FunctionNotUnderstood) returns (google.protobuf.Empty);
    // rpc Sigh (FunctionNotSupported) returns (google.protobuf.Empty);
    // rpc NevermindCapabilities (TerminalCapabilitySetRelease) returns (google.protobuf.Empty);
    // rpc NevermindChannelClose (RequestChannelCloseRelease) returns (google.protobuf.Empty);
    // rpc NevermindModeRequest (RequestModeRelease) returns (google.protobuf.Empty);
    rpc ConfirmLogicalChannel (OpenLogicalChannelConfirm) returns (google.protobuf.Empty);
    rpc SendJitterWarning (JitterIndication) returns (google.protobuf.Empty);
    rpc SendUserInput (UserInputIndication) returns (google.protobuf.Empty);
    rpc SendSkewWarning (H2250MaximumSkewIndication) returns (google.protobuf.Empty);
    rpc DiscloseMC (MCLocationIndication) returns (google.protobuf.Empty);
    rpc DiscloseVendor (VendorIdentification) returns (google.protobuf.Empty);
    rpc NevermindRate (LogicalChannelRateRelease) returns (google.protobuf.Empty);
    rpc IndicateFlowChange (FlowControlIndication) returns (google.protobuf.Empty);

    // Miscellaneous Commands

    rpc EqualizeDelay (Uint32Wrapper) returns (google.protobuf.Empty);
    rpc ZeroDelay (Uint32Wrapper) returns (google.protobuf.Empty);

    // Equivalent to multipointModeCommand
    rpc EnterMultipointMode (Uint32Wrapper) returns (google.protobuf.Empty);

    // Equivalent to cancelMultipointModeCommand
    rpc ExitMultipointMode (Uint32Wrapper) returns (google.protobuf.Empty);

    // Equivalent to videoFreezePicture
    rpc FreezeVideo (Uint32Wrapper) returns (google.protobuf.Empty);

    // Equivalent to videoFastUpdatePicture
    rpc FastUpdate (Uint32Wrapper) returns (google.protobuf.Empty);

    // Equivalent to videoSendSyncEveryGOB
    rpc SendSyncEveryGOB (Uint32Wrapper) returns (google.protobuf.Empty);
    // TODO: Do you need a command to cancel the above?

    // This performs SwitchReceiveMediaOn when the argument is true and
    // SwitchReceiveMediaOff when the argument is false.
    rpc ToggleReceiveMedia (BoolWrapper) returns (google.protobuf.Empty);

    // Equivalent to progressiveRefinementAbortOne
    rpc AbortOneProgressiveRefinement (Uint32Wrapper) returns (google.protobuf.Empty);

    // Equivalent to progressiveRefinementAbortContinuous
    rpc AbortContinuousProgressiveRefinement (Uint32Wrapper) returns (google.protobuf.Empty);

    rpc DoVideoFastUpdateGOB (VideoFastUpdateGOB) returns (google.protobuf.Empty);
    rpc VideoTemporalSpatialTradeOff (Uint32Wrapper) returns (google.protobuf.Empty);
    rpc VideoSendSyncEveryGOB (google.protobuf.Empty) returns (google.protobuf.Empty);
    rpc DoVideoFastUpdateMB (VideoFastUpdateMB) returns (google.protobuf.Empty);
    rpc MaxH223MUXPDUsize (Uint32Wrapper) returns (google.protobuf.Empty);
    rpc EncryptionUpdate (EncryptionSync) returns (google.protobuf.Empty);
    rpc DoEncryptionUpdateRequest (EncryptionUpdateRequest) returns (google.protobuf.Empty);
    rpc DoProgressiveRefinementStart (ProgressiveRefinementStart) returns (google.protobuf.Empty);
    rpc DoVideoBadMBs (VideoBadMBs) returns (google.protobuf.Empty);
    rpc DoLostPicture (LostPicture) returns (google.protobuf.Empty);
    rpc DoLostPartialPicture (LostPartialPicture) returns (google.protobuf.Empty);
    rpc DoRecoveryReferencePicture (RecoveryReferencePicture) returns (google.protobuf.Empty);
    rpc DoEncryptionUpdateCommand (EncryptionUpdateCommand) returns (google.protobuf.Empty);

    // argument is the synchFlag
    rpc EncryptionUpdateAck (Uint32Wrapper) returns (google.protobuf.Empty);

    // If argument is true, this behaves like logicalChannelActive.
    // If argument is false, this behaves like logicalChannelInactive.
    rpc LogicalChannelActivityIndication (BoolWrapper) returns (google.protobuf.Empty);

    // If argument is true, this behaves like multipointConference.
    // If argument is false, this behaves like cancelMultipointConference.
    rpc MultipointConference (BoolWrapper) returns (google.protobuf.Empty);

    // If argument is true, this behaves like multipointZeroComm.
    // If argument is false, this behaves like cancelMultipointZeroComm.
    rpc MultipointZeroComm (BoolWrapper) returns (google.protobuf.Empty);

    // If argument is true, this behaves like multipointSecondaryStatus.
    // If argument is false, this behaves like cancelMultipointSecondaryStatus.
    rpc MultipointSecondaryStatus (BoolWrapper) returns (google.protobuf.Empty);

    rpc VideoIndicateReadyToActivate (google.protobuf.Empty) returns (google.protobuf.Empty);
    rpc DoVideoNotDecodedMBs (VideoNotDecodedMB) returns (google.protobuf.Empty);
    rpc DoTransportCapability (TransportCapability) returns (google.protobuf.Empty);

    // Conference API

    // In H.245, there are separate terminalListRequest and requestAllTerminalIDs commands. Not here.
    rpc GetTerminalList (google.protobuf.Empty) returns (RequestAllTerminalIDsResponse);
    rpc MakeMeChair (google.protobuf.Empty) returns (BoolWrapper);
    rpc DropTerminal (TerminalLabel) returns (BoolWrapper); // TODO: Should this really be a boolean?
    rpc RequestMCTerminalID (TerminalLabel) returns (TerminalInformation);
    rpc BroadcastMyLogicalChannel (Uint32Wrapper) returns (BoolWrapper);
    rpc MakeTerminalBroadcaster (TerminalLabel) returns (BoolWrapper);
    rpc DropConference (google.protobuf.Empty) returns (google.protobuf.Empty);
    // TODO: Should there be some API for returning MY terminal label?
    // TODO: Should there just be a general conference info API? Perhaps returned upon establishing a call?
    // Conference ID, terminals, MCs

    // TODO: Multi-select and unselect terminals
    rpc FocusTerminal (TerminalLabel) returns (BoolWrapper); // Equivalant to sendThisSource
    rpc DoRemoteMCRequest (RemoteMCRequest) returns (RemoteMCResponse);
    rpc ChangeConference (SubstituteConferenceIDCommand) returns (google.protobuf.Empty);

    rpc EnterH243Password (google.protobuf.Empty) returns (google.protobuf.Empty);
    rpc EnterH243TerminalID (google.protobuf.Empty) returns (google.protobuf.Empty);
    rpc EnterH243ConferenceID (google.protobuf.Empty) returns (google.protobuf.Empty);
    rpc EnterExtensionAddress (google.protobuf.Empty) returns (google.protobuf.Empty);
    rpc RequestChairTokenOwner (google.protobuf.Empty) returns (google.protobuf.Empty);
    rpc RequestTerminalCertificate (RequestTerminalCertArg) returns (google.protobuf.Empty);

    rpc DoPasswordResponse (PasswordResponse) returns (google.protobuf.Empty);
    rpc VideoCommandReject (google.protobuf.Empty) returns (google.protobuf.Empty);
    rpc TerminalDropReject (google.protobuf.Empty) returns (google.protobuf.Empty);
    rpc ChairTokenOwnerResponse (TerminalInformation) returns (google.protobuf.Empty);
    rpc DoTerminalCertificateResponse (TerminalCertificateResponse) returns (google.protobuf.Empty);
}

// TODO: Additional Features
// - Recording
// - Geolocation
// - Drawing